import pprint as pp
from typing import Annotated, Any, Callable, List, Optional, Type

import matplotlib.pyplot as plt
import openai
import pandas as pd
from dotenv import load_dotenv
from langchain_core.prompts import ChatPromptTemplate
from langchain_experimental.utilities import PythonREPL
from langchain_openai import ChatOpenAI
from langgraph.constants import END, START
from pydantic import BaseModel, Field
from typing_extensions import TypedDict

from agent.stub import CustomAgent

load_dotenv()


def get_data_description(df_):
    data_desc = [(col_name, df_[col_name].dtypes.name) for col_name in df_.columns]
    return data_desc


df = None

# Fill with your LLM id. For example, if you have an OpenAI connection called "myopenai", LLM_ID can be "openai:myopenai:gpt-4o"
# To get the list of LLM ids, you can use project.list_llms() (see above)
llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)


# Data model
class PythonCode(BaseModel):
    """Schema for the python pandas code."""

    prefix: str = Field(description="Description of the problem and approach")
    imports: str = Field(description="ONLY the import statements from code block.")
    code: str = Field(description="Code block not including import statements")


code_gen_sys_prompt = """You are an excellent python coder specializing in writing code for data \
manipulation using Pandas library. Answer the user question based on the below provided data description. {data_desc}\
Ensure any code you provide can be executed with all required imports and variables defined, and \
final output is printed. The pandas dataframe is loaded in memory in variable name `df`. \
Structure your answer with a description of the code solution. Then list the imports. \
And finally list the functioning code block.
"""

prompt = ChatPromptTemplate.from_messages(
    [
        ("system", code_gen_sys_prompt),
        ("placeholder", "{messages}"),
    ]
)

code_gen_llm = prompt | llm.with_structured_output(PythonCode)


class PlotOutputCode(BaseModel):
    """Schema for plotting code."""

    viz_choice: str = Field(..., description="Choice of visualization type")
    viz_choice_reason: str = Field(
        ..., description="Reasoning for the choice of visualization"
    )
    imports: str = Field(..., description="ONLY the import statements from code block.")
    code: str = Field(
        ..., description="Python code block not including import statements"
    )


viz_agent_system_prompt_text = """You are tasked with generating Python code using the matplotlib library \
to visualize the output of a pandas operation. You will be given query asked by the user and the output \
generated by running the pandas code.

Your goal is to create a suitable visualization for this data using matplotlib. Follow these steps:

1. Analyze the pandas output:
   - Identify the structure of the data (e.g., series, dataframe, single value)
   - Determine the types of variables (e.g., numerical, categorical, temporal)
   - Note the number of data points or rows

2. Choose an appropriate visualization type based on the data:
   - Text/Annotation in a figure for a single value.
   - For time series data, consider line plots
   - For categorical comparisons, consider bar plots or pie charts
   - For numerical distributions, consider histograms or box plots
   - For relationships between variables, consider scatter plots

3. Generate the matplotlib code:
   - Import necessary libraries (matplotlib.pyplot as plt)
   - Create a figure and axis object
   - Plot the data using the appropriate plot type
   - Add labels, title, and legend according to the user question.
   - Adjust any styling or formatting to enhance readability.
   - Have a nice grey background color to the figure.
   - Save the figure as "figure.png"
   -DO NOT Include plt.show() at the end

4. Provide a brief explanation of why you chose this visualization type and how it represents the data effectively.

Write your code and explanation inside <matplotlib_code> tags. Ensure the code is complete, properly indented, and ready to run. Here's an example of how your output should be structured:

<matplotlib_code>
import matplotlib.pyplot as plt

# Your visualization code here
# ...

plt.savefig("figure.png")

Explanation: This visualization was chosen because...
</matplotlib_code>

Remember to tailor the visualization to the specific data provided in the pandas output and the user query. \
If you need any clarification about the data, please ask before generating the code."""


viz_agent_sys_prompt = ChatPromptTemplate.from_messages(
    [
        ("system", viz_agent_system_prompt_text),
        ("placeholder", "{messages}"),
    ]
)


viz_agent = viz_agent_sys_prompt | llm.with_structured_output(PlotOutputCode)


# ## Build the graph


class GraphState(TypedDict):
    """
    Represents the state of our graph.

    Attributes:
        error : Binary flag for control flow to indicate whether test error was tripped
        messages : With user question, error messages, reasoning
        pandas_code : Pandas Code solution
        iterations : Number of tries
        final_answer: Final answer from pandas output
        pandas_code_output: Output from pandas code
        viz_code: Visualization code
    """

    error: str
    iterations: int
    user_query: str
    messages: List
    pandas_code: str
    pandas_code_output: str
    final_answer: str
    viz_code: str


## Parameters

# Max tries
MAX_ITERATIONS = 3

# -------------------------------------------------------------------------------- NOTEBOOK-CELL: MARKDOWN
# ### Node functions


def generate_pandas_code(state: GraphState) -> dict:
    """
    Generate a pandas code solution

    Args:
        state (dict): The current graph state

    Returns:
        state (dict): New key added to state, generation
    """

    print("---GENERATING CODE SOLUTION---")

    # State
    messages = state["messages"]
    iterations = state["iterations"]
    error = state["error"]

    # We have been routed back to generation with an error
    if error == "yes":
        messages += [
            (
                "user",
                "Now, try again. Invoke the code tool to structure the output with a prefix, imports, and code block:",
            )
        ]

    # Solution
    code_solution = code_gen_llm.invoke(
        {"data_desc": get_data_description(df_=df), "messages": messages}
    )
    messages += [
        (
            "assistant",
            f"{code_solution.prefix} \n Imports: {code_solution.imports} \n Code: {code_solution.code}",
        )
    ]

    # Increment
    iterations = iterations + 1
    return {
        "pandas_code": code_solution,
        "messages": messages,
        "iterations": iterations,
    }


def check_pandas_code(state: GraphState) -> dict:
    """
    Check Pandas code

    Args:
        state (dict): The current graph state

    Returns:
        state (dict): New key added to state, error
    """

    print("---CHECKING PANDAS CODE---")

    # State
    messages = state["messages"]
    code_solution = state["pandas_code"]

    # Get solution components
    imports = code_solution.imports
    code = code_solution.code

    # Check imports
    try:
        exec(imports)
    except Exception as e:
        print("---CODE IMPORT CHECK: FAILED---")
        error_message = [("user", f"Your solution failed the import test: {e}")]
        messages += error_message
        return {
            "pandas_code": code_solution,
            "messages": messages,
            "error": "yes",
        }

    # Check execution
    try:
        exec(imports + "\n" + code)
    except Exception as e:
        print("---CODE BLOCK CHECK: FAILED---")
        error_message = [("user", f"Your solution failed the code execution test: {e}")]
        messages += error_message
        return {
            "pandas_code": code_solution,
            "messages": messages,
            "error": "yes",
        }

    # No errors
    print("---NO CODE TEST FAILURES---")
    python_repl = PythonREPL(_locals={"df": df})
    code_response = python_repl.run(imports + "\n" + code)
    messages += [
        (
            "user",
            f"The pandas code was executed successfully and generated the following response: {code_response}",
        )
    ]
    return {
        "pandas_code": code_solution,
        "messages": messages,
        "iterations": 0,
        "pandas_code_output": code_response,
        "error": "no",
    }


class FinalAnswer(BaseModel):
    final_answer: str = Field(
        ...,
        description="Final answer to user query based on the results of python code execution",
    )


def generate_final_answer(state: GraphState) -> dict:
    """
    Generate Final Answer

    Args:
        state (dict): The current graph state

    Returns:
        state (dict): New key added to state, generation

    """
    print(f"---GENERATING FINAL ANSWER---")
    messages = state["messages"]
    errors = state["error"]

    if errors == "no":
        final_ans_llm = llm.with_structured_output(FinalAnswer)

        final_answer = final_ans_llm.invoke(messages)

        return {"final_answer": final_answer}

    else:
        return {
            "final_answer": "There is an issue in generating answer to this query. Please try after some time."
        }


def generate_viz_code(state: GraphState) -> dict:
    """
    Generate matplotlib code to visualize
    """
    print("---GENERATING VISUALIZATION CODE---")

    pandas_output = state["pandas_code_output"]
    messages = state["messages"]
    iterations = state["iterations"]
    user_query = messages[0][1]

    viz_agent = viz_agent_sys_prompt | llm.with_structured_output(PlotOutputCode)

    response = viz_agent.invoke(
        {
            "messages": [
                ("human", f"User Question: {user_query}\n\nOutput: {pandas_output}")
            ]
        }
    )

    messages += [
        (
            "assistant",
            f"{response.viz_choice_reason} \n Imports: {response.imports} \n Code: {response.code}",
        )
    ]

    # Increment
    iterations = iterations + 1
    return {"viz_code": response, "messages": messages, "iterations": iterations}


def check_viz_code(state: GraphState) -> dict:
    """
    Check visualization code

    Args:
        state (dict): The current graph state

    Returns:
        state (dict): New key added to state, error
    """

    print("---CHECKING VISUALIZATION CODE---")

    # State
    messages = state["messages"]
    code_solution = state["viz_code"]

    # Get solution components
    imports = code_solution.imports
    code = code_solution.code

    # Check imports
    try:
        exec(imports)
    except Exception as e:
        print("---VIZ CODE IMPORT CHECK: FAILED---")
        error_message = [
            ("user", f"Your visualization code solution failed the import test: {e}")
        ]
        messages += error_message
        return {
            "viz_code": code_solution,
            "messages": messages,
            "error": "yes",
        }

    # Check execution
    try:
        exec(imports + "\n" + code)
    except Exception as e:
        print("---VIZ CODE BLOCK CHECK: FAILED---")
        print(e)
        error_message = [
            (
                "user",
                f"Your visualization code solution failed the code execution test: {e}",
            )
        ]
        messages += error_message
        return {
            "viz_code": code_solution,
            "messages": messages,
            "error": "yes",
        }

    # No errors
    print("---NO VIZ CODE TEST FAILURES---")
    messages += [("user", f"The visualzation code was executed successfully,")]
    return {
        "viz_code": code_solution,
        "messages": messages,
        "iterations": 0,
        "error": "no",
    }


def pandas_code_cond(state: GraphState) -> str:
    """
    Determines whether to generate a final answer and plot.

    Args:
        state (dict): The current graph state

    Returns:
        str: Next node to call
    """
    error = state["error"]
    iterations = state["iterations"]

    if error == "no" or iterations == MAX_ITERATIONS:
        print(f"---DECISION: GENERATE FINAL ANSWER WITH {iterations} iterations---")
        return "generate_final_answer"

    if error == "yes":
        print("---DECISION: GENERATE PANDAS CODE AGAIN---")
        return "generate_pandas_code"


def viz_code_cond(state: GraphState) -> str:
    """
    Determines whether to end graph or not.

    Args:
        state (dict): The current graph state

    Returns:
        str: Next node to call
    """
    error = state["error"]
    iterations = state["iterations"]

    if error == "no" or iterations == MAX_ITERATIONS:
        print("---DECISION: END GRAPH---")
        return END

    else:
        print("---DECISION: GENERATE VIZ CODE AGAIN---")
        return "generate_viz_code"


agent = CustomAgent(
    state_schema=GraphState,
    impl=[
        ("generate_pandas_code", generate_pandas_code),
        ("check_pandas_code", check_pandas_code),
        ("generate_final_answer", generate_final_answer),
        ("generate_viz_code", generate_viz_code),
        ("check_viz_code", check_viz_code),
        ("pandas_code_cond", pandas_code_cond),
        ("viz_code_cond", viz_code_cond),
    ],
)

compiled_agent = agent.compile()


def stream_graph_updates(question):
    if df is None:
        raise ValueError("No DataFrame has been loaded yet")

    response = compiled_agent.invoke(
        {"messages": [("user", question)], "iterations": 0, "error": ""}
    )

    return response
